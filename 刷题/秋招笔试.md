## lambda函数
```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

int greater1(int firstVal, int secondVal) {
	return firstVal > secondVal ? true : false;
} //greater是保留字

void findSpecificValue(const std::vector<int>& vec, int specificValue) {
	auto iter = vec.begin();
	iter = find_if(iter, vec.end(), std::bind(greater1, std::placeholders::_1, specificValue));
	if (iter != vec.end()) {
		cout << "greater than" << specificValue << ":" << *iter << endl;
	}
}

int main() {
	vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };
	findSpecificValue(vec, 8); 
	system("pause");
	return 0;
}


```
修改为`lambda`形式，只能输出`9`
```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

bool greater(int firstVal, int secondVal) {
	return firstVal > secondVal ? true : false;
}

void findSpecificValue(const std::vector<int>& vec, int specificValue) {
	auto iter = vec.begin();
	while (iter != vec.end()) {
		iter = find_if(iter, vec.end(), [specificValue](const int &a) {return a > specificValue; });
		if (iter != vec.end()) {
			cout << "greater than" << specificValue << ":" << *iter << endl;
		}
		iter++;
	}
}

int main() {
	vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };
	findSpecificValue(vec, 8);
	system("pause");
	return 0;
}
```

## String构造函数
```C++

```

## 翻转字串

假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成，要求只能调用一次检查子串的函数。

给定两个字符串`s1`,`s2`,请返回`bool`值代表`s2`是否由`s1`旋转而成。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。

```C++
//考点：str.find(substr)
class ReverseEqual {
public:
	bool checkReverseEqual(string s1, string s2) {
		// write code here
		int len1 = s1.size(), len2 = s2.size();
		if (len1 != len2) return false;
		if (len1 == 0 || len2 == 0) return false;
		string str = s1 + s1;
		if (str.find(s2) == -1) return false;
		else return true;
	}
};
```

## 二叉树平衡检查
二叉树平衡的定义：空树且左右子树的高度不超过1，并且左右子树的子树也是平衡二叉树。

```C++
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
using namespace std;

struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
		val(x), left(NULL), right(NULL) {}
};

class Balance {
public:
	int calhigh(TreeNode* root) {
		if (root == nullptr) return 0;
		return 1 + max(calhigh(root->right), calhigh(root->left));
	}
	bool isBalance(TreeNode* root) {
		// write code here
		if (root == nullptr) return true;
		int left = calhigh(root->left);
		int right = calhigh(root->right);
		bool flag = (abs(left - right) <= 1);
		return flag && isBalance(root->left) && isBalance(root->right);
	}
};
```

## 整数转化
编写一个函数，确定需要改变几位，才能将整数A转变为整数B，给定两个整数int A，int B,请返回需要改变数位的位数

	思路：
	1）这两个整数都需要转换为2进制表示，旨在求出这两个整数bit数不同的位数，考虑其中一个按位操作不同的数，异或操作之后1的个数。
	2）怎么求解异或操作之后1的个数，异或之后的结果依旧放在int里吗？计算一个数的1的个数，采用 n = n & (n-1) 的方式；
	

```C++
class Transform {
public:
	int calcCost(int A, int B) {
		// write code here
		int res = A ^ B;
		int count = 0;
		while (res) {
			count++;
			res = res & (res - 1);
		}
		return count;
	}
};
```