<!-- GFM-TOC -->
* [1. TwoSum](#1-TwoSum)
* [2. AddTwoNumbers](#2-AddTwoNumbers)
* [3. LongestSubstringWithoutRepeatingCharacters](#3-LongestSubstringWithoutRepeatingCharacters)

<!-- GFM-TOC -->

# 1. TwoSum

给定一个整数数组，返回两个数之和等于target的数组索引。

我的思路：夹逼准则，先排序，然后首位寻找是否等于target的数。但是这样排序改变了原来数组的下标，先找到这两个数，然后返回下标。

最简单的方法是穷举搜索，一个是x，另外一个是target-x；复杂度O(n^2)

优化方法：两次hash表操作，对在一维数组中查找target-x优化。

进一步优化：一次hash表操作，边建立hash表边返回。

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		vector<int> res;
		int size = nums.size();
		if (size <= 1) return res;
		vector<int> nums_sort(nums);
		sort(nums_sort.begin(), nums_sort.end());
		int i = 0, j = size - 1;
		while (i <= size - 1 && j >= i) {
			if (nums_sort[i] + nums_sort[j] == target) {
				break;
			}
			else if (nums_sort[i] + nums_sort[j] > target) {
				j--;
			}
			else {
				i++;
			}
		}

		for (int k = 0; k < size; k++) {
			if (nums[k] == nums_sort[i] || nums[k] == nums_sort[j])
				res.push_back(k);
		}		
		return res;
	}
};
```

# 2. AddTwoNumbers
两个非负整数的非空链表，整数数字是逆序存储的，每个节点存有单一的数字，将两个数相加然后将结果返回为一个链表。

```C++
struct ListNode {
	int val;
	ListNode *next;
	ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
	ListNode * addTwoNumbers(ListNode* l1, ListNode* l2) {
		ListNode *res = new ListNode(0);
		ListNode *p = l1, *q = l2, *reshead = res;
		int carry = 0;
		while (p != nullptr || q != nullptr) {
			int x = (p != nullptr) ? p->val : 0;
			int y = (q != nullptr) ? q->val : 0;
			int sum = x + y + carry;
			carry = sum / 10;
			res->next = new ListNode(sum % 10);
			res = res->next;
			if (p != nullptr) p = p->next;
			if (q != nullptr) q = q->next;
		}
		if (carry > 0) {
			res->next = new ListNode(carry);
		}
		return reshead->next;
	}
};
```

# 3. LongestSubstringWithoutRepeatingCharacters
给定一个字符串，找到无重复字符的最长字串。

穷举搜索的方法：定义一个函数，判断字串是否含有重复字符，如果有重复字符`false`，问题更新为返回无重复的字串的最大长度。

```C++
class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		int res = 0;
		int length = s.length();
		for (int i = 0; i < length; i++)
			for (int j = i + 1; j <= length; j++)
				if (allUnique(s, i, j)) res = max(res, j - i);
		return res;
	}

	bool allUnique(string s, int start, int end) {
		set<char> substr;
		for (int i = start; i < end; i++) {
			char ch = s[i];
			if (substr.find(ch) != substr.end()) return false;
			substr.insert(ch);
		}
        return true;
	}
};
```
std::set [用法](https://www.cnblogs.com/zyxStar/p/4542835.html)

用穷举搜索的方法，时间复杂度较高，不通过。

优化方法：滑动窗口，滑动窗口是在数组和字符串中常用的一个抽象概念。

```C++
class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		vector<char> substr;
		int res = 0;
		for (int i = 0; i < s.length(); i++) {
			auto it = find(substr.begin(), substr.end(), s[i]);
			if (it != substr.end()) {//找到了
				if (res < substr.size())
					res = substr.size();
				it++;
				substr.erase(substr.begin(), it);
			}
			substr.push_back(s[i]);
		}

		if (res < substr.size())
			res = substr.size();

		return res;
	}
};
```