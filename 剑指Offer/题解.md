<!-- GFM-TOC -->
* [前言](#前言)
* [1. 二维数组中的查找](#1-二维数组中的查找)
* [2. 替换空格](#2-替换空格)
* [3. 从尾到头打印链表](#3-从尾到头打印链表)
* [4. 重建二叉树](#4-重建二叉树)
* [5. 用两个栈实现队列](#5-用两个栈实现队列)
* [6. 旋转数组的最小数字](#6-旋转数组的最小数字)
* [7. 斐波那契数列](#7-斐波那契数列)
* [8. 跳台阶](#8-跳台阶)
* [9. 变态跳台阶](#9-变态跳台阶)
* [10. 矩形覆盖](#10-矩形覆盖)
* [11. 二进制中1的个数](#11-二进制中1的个数)
* [12. 数值的整数次方](#12-数值的整数次方)
* [13. 调整数组顺序使奇数位于偶数前面](#13-调整数组顺序使奇数位于偶数前面)
* [14. 链表中倒数第k个结点](#14-链表中倒数第k个结点)
* [15. 反转链表](#15-反转链表)
* [16. 合并两个排序的链表](#16-合并两个排序的链表)
* [17. 树的子结构](#17-树的子结构)
* [18. 二叉树的镜像](#18-二叉树的镜像)
* [19. 顺时针打印矩阵](#19-顺时针打印矩阵)
<!-- GFM-TOC -->

# 前言

`无他，唯手熟尔`

# 1. 二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```C++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int row = (int)array.size();
        int col = (int)array[0].size();
        
        if(row == 0 || col == 0)
            return false;
        
        if(target < array[0][0] || target > array[row-1][col-1])
            return false;
        
        for(int i=0;i<row;i++){
            int l = 0,r = col - 1,m;
            while(l <= r){
                m = (l+r)/2;
                if(target == array[i][m])
                    return true;
                else if(target < array[i][m])
                    r = m - 1;
                else
                    l = m + 1;
            }
        }
        
        return false;
    }
};
```

# 2. 替换空格

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```C++
class Solution {
public:
	void replaceSpace(char *str, int length) {
		int count = 0;
		for (int i = 0; i < length; i++) {
			if (str[i] == ' ')
				count++;
		}

		for (int i = length - 1; i >= 0; i--) {
			if (str[i] != ' ') {
				str[i + 2*count] = str[i];
			}
			else {
				count--;
				str[i + 2*count] = '%';
				str[i + 2 * count + 1] = '2';
				str[i + 2 * count + 2] = '0';
			}
		}
	}
};
```

# 3. 从尾到头打印链表

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

```C++
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
	vector<int> printListFromTailToHead(ListNode* head) {
		vector<int> list;
		if (head != NULL) {
			list.insert(list.begin(), head->val);
			if (head->next != NULL) {
				vector<int> tempVal = printListFromTailToHead(head->next);
				if (tempVal.size() > 0)
					list.insert(list.begin(), tempVal.begin(), tempVal.end());
			}
		}
		return list;
	}
};
```

# 4. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/**
* Definition for binary tree */
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	TreeNode * reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		int vin_len = vin.size();
		if (vin_len == 0)
			return NULL;

		vector<int> pre_left, pre_right, vin_left, vin_right;

		TreeNode *root = new TreeNode(pre[0]);

		int root_index = 0;
		for (int i = 0; i < vin_len; i++) {
			if (vin[i] == root->val) {
				root_index = i;
				break;
			}
		}
		//构建左子树
		for (int i = 0; i < root_index; i++) {
			vin_left.push_back(vin[i]);
			pre_left.push_back(pre[i + 1]);
		}
		//构建右子树
		for (int i = root_index + 1; i < vin_len; i++) {
			vin_right.push_back(vin[i]);
			pre_right.push_back(pre[i]);
		}
		root->left = reConstructBinaryTree(pre_left, vin_left);
		root->right = reConstructBinaryTree(pre_right, vin_right);
		return root;
	}

	vector<int> PrintFromTopToBottom(TreeNode* root) {
		TreeNode* fr;
		if (root == NULL) {
			return result;
		}
		que.push(root);
		while (!que.empty()) {
			fr = que.front();
			result.push_back(fr->val);
			if (fr->left != NULL) {
				que.push(fr->left);
			}
			if (fr->right != NULL) {
				que.push(fr->right);
			}
			que.pop();
		}
		return result;
	}
private:
	vector<int> result;
	queue<TreeNode*> que;

};

int main() {
	Solution s;
	int a[8] = { 1,2,4,7,3,5,6,8 };
	int b[8] = { 4,7,2,1,5,3,8,6 };
	vector<int> pre;
	pre.insert(pre.begin(), a, a + 8);
	vector<int> vin;
	vin.insert(vin.begin(), b, b + 8);
	TreeNode *root = s.reConstructBinaryTree(pre, vin);
	vector<int> result = s.PrintFromTopToBottom(root);
	vector<int>::iterator it;
	for (it = result.begin(); it != result.end(); ++it) {
		cout << *it << endl;
	}

	system("pause");
	return 0;
}

/*
*                   1
*                 *    *
*              2          3
*            *           *   *
*          4            5      6
*         *
*       8
*/
```

# 5. 用两个栈实现队列

```C++
/* 题目：用两个栈实现队列
* 题目描述
* 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
*/

#include<iostream>
#include<stack>
using namespace std;

class Solution
{
public:
	void push(int node) {
		stack1.push(node);
	}

	int pop() {
		int res = 0;
		if (stack2.size() > 0) {
			res = stack2.top();
			stack2.pop();
		}
		else if (stack1.size() > 0) {
			while (stack1.size() > 0) {
				stack2.push(stack1.top());
				stack1.pop();
			}
			res = stack2.top();
			stack2.pop();
		}
		return res;
	}

private:
	stack<int> stack1;
	stack<int> stack2;
};

int main() {
	Solution s;
	s.push(5);
	s.push(6);
	s.pop();
	system("pause");
	return 0;
}
```

# 6. 旋转数组的最小数字

```C++
/* 题目：旋转数组的最小数字
* 题目描述
* 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
* 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。
* 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
* NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
*/

#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
	int minNumberInRotateArray(vector<int> rotateArray) {
		int size = rotateArray.size();
		if (size == 0) {
			return 0;
		}
		int left = 0, right = size - 1;
		int mid = 0;
		while (rotateArray[left] >= rotateArray[right]) {
			if (right - left == 1) {
				mid = right;
				break;
			}
			mid = (left + right) / 2;
			if (rotateArray[left] == rotateArray[right] && rotateArray[left] == rotateArray[mid]) {
				return MinNumber(rotateArray, left, right);
			}
			if (rotateArray[mid] >= rotateArray[left]) {
				left = mid;
			}
			else {
				right = mid;
			}
		}
		return rotateArray[mid];
	}
private:
	int MinNumber(vector<int> &num, int left, int right) {
		int res = num[left];
		for (int i = left + 1; i < right; i++) {
			if (num[i] < res) {
				res = num[i];
			}
		}
		return res;
	}
};

int main() {
	Solution s;
	vector<int> num = { 4,5,6,7,1,2,3 };
	cout << s.minNumberInRotateArray(num) << endl;
	system("pause");
	return 0;
}
```

# 7. 斐波那契数列

```C++
/* 题目：斐波那契数列
* 题目描述
* 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
*/

#include<iostream>
using namespace std;

class Solution {
public:
	/*int Fibonacci(int n) {
	if (n < 0)
	return -1;
	else if (n == 0)
	return 0;
	else if (n == 1)
	return 1;
	else
	return Fibonacci(n - 1) + Fibonacci(n - 2);
	}*/ //递归时间消耗太大
	int Fibonacci(int n) {
		if (n < 0)
			return -1;
		else if (n == 0)
			return 0;
		else if (n == 1 || n == 2)
			return 1;
		else {
			int first = 1, second = 1, temp;
			for (int i = 2; i < n; i++) {
				temp = first + second;
				first = second;
				second = temp;
			}
			return temp;
		}
	}
};

int main() {
	Solution s;
	cout << s.Fibonacci(5) << endl;
	system("pause");
	return 0;
}
```

# 8. 跳台阶

```C++
/* 题目：跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
* 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 总跳法是f(n) = f(n-1) + f(n-2);
f(1) = 1; f(2) = 2; f(3) = 3;Fibonacci数列
*/

/* 
* 递归方法对时间和空间的消耗比较大。
*/

#include<iostream>
using namespace std;

class Solution {
public:
	int jumpFloor(int number) {
		/*if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			return jumpFloor(number - 1) + jumpFloor(number - 2);
		}*/
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if(number == 2){
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloor(5) << endl;
	system("pause");
	return 0;
}
```

# 9. 变态跳台阶

```C++
#include<iostream>
using namespace std;

/* 题目：变态跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 第一次跳是n级，那么剩下的是0个台阶，跳法是f(0);
总跳法是f(n) = f(n-1) + f(n-2) + ... + f(1) + f(0);
f(n - 1) = f(n - 2) + ... + f(0);
f(n) = f(n-1)+ f(n-1) = 2*f(n-1);
f(0) = 1;
f(1) = 1;
f(2) = 2;
*/

class Solution {
public:
	int jumpFloorII(int number) {
		if (number == 0 || number == 1) {
			return 1;
		}
		else if (number > 0) {
			int res = 1;
			for (int i = 2; i <= number; i++) {
				res = 2 * res;
			}
			return res;
		}
		else {
			return 0;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloorII(5) << endl;
	system("pause");
	return 0;
}
```

# 10. 矩形覆盖

```C++
#include<iostream>
using namespace std;

/* 题目：矩形覆盖
* 题目描述
* 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
* 请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
*/

/* 
1. 当n=1时，只有一种方法；
2. 当n=2时，有两种方法；
第一块横着放，f(n-2)种放法；
第一块竖着放，f(n-1)种放法。
f(n) = f(n-1) + f(n-2);
*/

class Solution {
public:
	int rectCover(int number) {
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}

	}
};

int main() {
	Solution s;
	cout << s.rectCover(4) << endl;
	system("pause");
	return 0;
}
```

# 11. 二进制中1的个数

```C++
#include<iostream>
using namespace std;

/* 题目：二进制中1的个数
* 题目描述
* 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
*/

/* 题解
* 一个整数：0，正数，负数
* 这个数转换为2进制表示
* 负数怎么转换为2进制表示呢？

*********
* 从n的2进制形式的最右边开始判断是不是1
* 该解法如果输入时负数会陷入死循环，因为负数右移时，在最高位补得是1,
* 本题最终目的是求1的个数，那么会有无数个1了。
**********
* 用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数
*/



class Solution {
public:
	int  NumberOf1(int n) {
		/*int count = 0;
		int flag = 1;
		while (flag != 0) {//停止条件 flag = 0，位数移动完毕
			if ((n & flag) != 0) {
				count++;				
			}
			flag = flag << 1;
		}
		return count;	*/
		int count = 0;
		while (n != 0) {
			count++;
			n = (n - 1) & n;
		}
		return count;
		
	}
};

int main() {
	Solution s;
	cout << s.NumberOf1(10) << endl;
	system("pause");
	return 0;
}
```

# 12. 数值的整数次方

```C++
#include<iostream>
using namespace std;

/* 题目：数值的整数次方
* 题目描述
* 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
* 考察点：代码的完整性
*/

/* 题解
* 底数base，指数exponent
* 指数为正，为0，为负三种情况
* 指数为正时,指数值为1时返回base，指数值大于1时的处理：
* 递归的方法，为偶数时，指数对半分；为奇数时，exponent/2，exponent/2+1

* 非递归方法，平方乘算法
*/

class Solution {
public:
	double Power(double base, int exponent) {
		/*if (exponent > 0) {
			if (exponent == 1) {
				return base;
			}
			else {
				if (exponent % 2 == 0) {
					return Power(base, exponent / 2) * Power(base, exponent / 2);
				}
				else {
					return Power(base, exponent / 2) * Power(base, exponent / 2 + 1);
				}
			}
		}
		else if (exponent == 0) {
			return 1;
		}
		else {
			return 1 / Power(base, 0 - exponent);
		}*/

		/*double res = 1, currentValue = base;
		int n = exponent;
		if (exponent > 0) {
			n = exponent;
		}
		else if (exponent < 0) {
			if (base == 0) {
				cout << "base cannot be zero!" << endl;
			}
			n = 0 - exponent;
		}
		else {
			return base;
		}
		while (n != 0) {
			if ((n & 1) != 0) {
				res *= currentValue;
			}
			currentValue *= currentValue;
			n >>= 1;
		}
		return res = exponent >= 0 ? res : (1 / res);*/
		return pow(base,exponent);
	}
};

int main() {
	Solution s;
	cout << s.Power(10,2) << endl;
	system("pause");
	return 0;
}
```

# 13. 调整数组顺序使奇数位于偶数前面

```C++
#include<iostream>
#include<vector>
using namespace std;

/* 题目：调整数组顺序使奇数位于偶数前面
* 题目描述
* 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
* 使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
* 并保证奇数和奇数，偶数和偶数之间的相对位置不变。
*/

/* 题解
* 空间换取时间
****************************
* 或者可以采取另外一种插排的方式
* 将偶数删除再添加到最后，erase
*/

class Solution {
public:
	void reOrderArray(vector<int> &array) {
		int size = (int)array.size();//返回size_t类型,int强制转换一下
		if (size == 0) {
			return ;
		}
		vector<int> oddArray;
		vector<int> evenArray;
		for (int i = 0; i < size; i++) {
			if (array[i] % 2 == 1) {
				oddArray.push_back(array[i]);
			}
			else {
				evenArray.push_back(array[i]);
			}
		}
		for (int i = 0; i < size; i++) {
			array.pop_back();
		}
		for (int i = 0; i < (int)oddArray.size(); i++) {
			array.push_back(oddArray[i]);
		}
		for (int i = 0; i < (int)evenArray.size(); i++) {
			array.push_back(evenArray[i]);
		}

		/*for (int i = 0; i < size; i++) {
			cout << array[i] << endl;
		}*/
	}
};
int main() {
	Solution s;
	vector<int> num = { 1,2,3,4,5,6 };
	s.reOrderArray(num);
	system("pause");
	return 0;
}
```

# 14. 链表中倒数第k个结点

[常见链表操作](https://github.com/selfconzrr/LinkedList_learning)

```C++
#include<iostream>
using namespace std;

/* 题目：链表中倒数第k个结点
* 题目描述
* 输入一个链表，输出该链表中倒数第k个结点。
*/

/* 题解
* 我的思路：遍历统计链表中结点的个数，然后根据个数再从前往后找所要寻找的结点
* 大神思路：两个指针，制造一个K长度的尺子，把尺子从头往后移动，
* 当尺子的右端与链表的末尾对齐的时候，尺子的左端所在的结点就是倒数第k个结点。
* 优点：遍历次数减少，刚好遍历k个，相对于全部遍历再加一部分遍历优化很多。
*/

/*
* 双指针定位
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

/*class Solution {
public:
	ListNode * FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL) {
			return NULL;
		}
		ListNode *res = pListHead;
		ListNode *tmp = pListHead;
		unsigned int n = 0;
		while (tmp != NULL) {
			n++;
			tmp = tmp->next;
		}
		if (k > n) {
			return NULL;
		}
		for (unsigned int i = 1; i < n - k + 1;i++) {
			res = res->next;
		}
		return res;
	}
};*/

class Solution {
public:
	ListNode * FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL) 
			return pListHead;
		if (k == 0) 
			return NULL;
		ListNode* kth = NULL, *end = pListHead;
		int count = 1;
		while (end != NULL) {
			if (count++ == k) {
				kth = pListHead;
			}
			else if (count>k) {
				kth = kth->next;
			}
			end = end->next;
		}
		return kth;
	}
};

int main() {
	Solution s;
	ListNode *res = NULL;
	s.FindKthToTail(res,2);
	system("pause");
	return 0;
}
```

# 15. 反转链表

```C++
#include<iostream>
#include<stack>
using namespace std;

/* 题目：反转链表
* 题目描述
* 输入一个链表，反转链表后，输出新链表的表头。
*/

/* 题解
* 利用stack进行链表反转，将原来链表依次压入栈，然后取出。
* 3个指针
* 递归
*/

/*链表初始化
* 要改变一下关于链表的思考方向。
* 即：
* 1、不要用初始化数组或结构的方式去处理链表；
* 2、链表的每一个节点要用一个子程序进行动态创建，同时赋值；
* 3、删除链表中的节点时，要注意回收内存；
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

class Solution {
public:
	/*ListNode * ReverseList(ListNode* pHead) {		
 		if (pHead == NULL || pHead->next == NULL) {
			return pHead;
		}
		stack<ListNode *> s;
		ListNode *p = pHead;
		while (p->next != NULL) {
			s.push(p);
			p = p->next;
		}
		ListNode *head = p;
		while (!s.empty()) {			
			p->next = s.top();						
			p = p->next;
			s.pop();
		}
		p->next = NULL;
		return head;
	}*/
	ListNode* ReverseList(ListNode* pHead) {

		if (pHead == NULL) {
			return pHead;
		}
		ListNode* pre = NULL;
		ListNode* cur = pHead;
		ListNode* nxt = NULL;
		while (cur != NULL) {
			nxt = cur->next;
			cur->next = pre;
			if (nxt == NULL) {
				break;
			}
			pre = cur;
			cur = nxt;
		}
		return cur;
	}
};

/*class Solution {
public:
	ListNode * ReverseList(ListNode* pHead) {
		//如果链表为空或者链表中只有一个元素
		if (pHead == NULL || pHead->next == NULL) return pHead;

		//先反转后面的链表，走到链表的末端结点
		ListNode* pReverseNode = ReverseList(pHead->next);

		//再将当前节点设置为后面节点的后续节点
		pHead->next->next = pHead;
		pHead->next = NULL;

		return pReverseNode;

	}
};*/

//尾插法建立单链表
ListNode * Creat_LinkList_R()
{
	int x;
	ListNode *head, *p, *tail;                    //tail是尾指针
	head = (ListNode*)malloc(sizeof(ListNode));
	if (head == NULL)
		return head;
	head->next = NULL;
	tail = head;                                  //一开始尾指针指向头指针的位置
	cout << "请输入要录入的数以0结束" << endl;
	cin >> x;
	head->val = x;
	while ((cin>>x) && (x != 0))
	{
		p = (ListNode*)malloc(sizeof(ListNode));
		if (p == NULL)
			return head;
		p->val = x;
		tail->next = p;                          //将p插入到尾节点的后面
		tail = p;                                //修改尾节点的指向
		tail->next = NULL;                       //将尾节点的指针域修改为空
	}
	return head;
}


int main() {
	Solution s;
	ListNode * res, *newList;
	res = Creat_LinkList_R();

	/*while (res != NULL) {		
		cout << res->val << endl;	
		res = res->next;
	}*/

	newList = s.ReverseList(res);

	while (newList != NULL) {
		cout << newList->val << endl;
		newList = newList->next;
	}

	system("pause");
	return 0;
}
```

# 16. 合并两个排序的链表
```C++
#include<iostream>
#include<stack>
using namespace std;

/* 题目：合并两个排序的链表
* 题目描述
* 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
*/

/* 题解
* 1. 非递归方法，依次比较，O(N)的时间复杂度
* 2. 递归方法
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

class Solution {
public:
	ListNode * Merge(ListNode* pHead1, ListNode* pHead2)
	{
		if (pHead1 == NULL) {
			return pHead2;
		}
		else if(pHead2 == NULL){
			return pHead1;
		}
		else {
			ListNode * newList;
			if (pHead1->val <= pHead2->val) {
				newList = pHead1;
				newList->next = Merge(pHead1->next,pHead2);
			}
			else {
				newList = pHead2;
				newList->next = Merge(pHead1, pHead2->next);
			}
			return newList;
		}
	}
};


//尾插法建立单链表
ListNode * Creat_LinkList_R()
{
	int x;
	ListNode *head, *p, *tail;                    //tail是尾指针
	head = (ListNode*)malloc(sizeof(ListNode));
	if (head == NULL)
		return head;
	head->next = NULL;
	tail = head;                                  //一开始尾指针指向头指针的位置
	cout << "请输入要录入的数以0结束" << endl;
	cin >> x;
	head->val = x;
	while ((cin >> x) && (x != 0))
	{
		p = (ListNode*)malloc(sizeof(ListNode));
		if (p == NULL)
			return head;
		p->val = x;
		tail->next = p;                          //将p插入到尾节点的后面
		tail = p;                                //修改尾节点的指向
		tail->next = NULL;                       //将尾节点的指针域修改为空
	}
	return head;
}

int main() {
	Solution s;
	ListNode *list1, *list2, *newList;
	list1 = Creat_LinkList_R();
	list2 = Creat_LinkList_R();

	/*while (res != NULL) {
	cout << res->val << endl;
	res = res->next;
	}*/

	newList = s.Merge(list1, list2);

	while (newList != NULL) {
		cout << newList->val << endl;
		newList = newList->next;
	}

	system("pause");
	return 0;
}


```

# 17. 树的子结构

```C++
#include<iostream>
#include<queue>
using namespace std;

/* 题目：树的子结构
* 题目描述
* 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
*/

/* 题解
* 递归
*/


struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
	bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
	{
		if (!pRoot1)
			return false;
		if (!pRoot2)
			return false;
		return ( doesTree1HasTree2(pRoot1, pRoot2) || HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2) );
	}
	bool doesTree1HasTree2(TreeNode* tree1, TreeNode* tree2) {
		if (!tree2) //tree2判断在前
			return true;
		if (!tree1)
			return false;
		if (tree1->val != tree2->val)
			return false;
		return (doesTree1HasTree2(tree1->left, tree2->left) && doesTree1HasTree2(tree1->right, tree2->right) );//这儿不应该递归调用HasSubtree
	}
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

int main() {
	Solution s;
	int nums[] = { 8,8,7,9,2,0,0,0,0,4,7};
	TreeNode *tree1 = initBTree(nums, 11);
	int nums2[] = { 8,9,2};
	TreeNode *tree2 = initBTree(nums2, 3);
	cout << s.HasSubtree(tree1, tree2) << endl;
	system("pause");
	return 0;
}
```

# 18. 二叉树的镜像

```C++
#include<iostream>
#include<queue>
using namespace std;

/* 题目：二叉树的镜像
* 题目描述
* 操作给定的二叉树，将其变换为源二叉树的镜像。
*/

/* 题解
* 递归
*/


struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
	void Mirror(TreeNode *pRoot) {
		if (!pRoot)
			return ;
		TreeNode * tmp;
		tmp = pRoot->right;
		pRoot->right = pRoot->left;
		pRoot->left = tmp;
		Mirror(pRoot->left);
		Mirror(pRoot->right);
	}
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

void preOrder(TreeNode *root, vector<int> &result)
{
	if (root)
	{
		result.push_back(root->val);
		preOrder(root->left, result);
		preOrder(root->right, result);
	}
}

void traverse(vector<int> nums)
{
	vector<int>::size_type size = nums.size();
	for (size_t i = 0; i < size; i++)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
}

int main() {
	Solution s;
	vector<int> preResult;
	vector<int> preResult2;
	int nums[] = { 8,6,10,5,7,9,11};
	TreeNode *tree1 = initBTree(nums, 7);
	preOrder(tree1, preResult);
	cout << "前序遍历的结果：" << '\n';
	traverse(preResult);
	s.Mirror(tree1);
	preOrder(tree1, preResult2);
	cout << "镜像的结果：" << '\n';
	traverse(preResult2);
	system("pause");
	return 0;
}
```

# 19. 顺时针打印矩阵

```C++
#include<iostream>
#include<vector>
using namespace std;

/* 题目：顺时针打印矩阵
* 题目描述
* 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
* 例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
* 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
*/

/* 题解
* 设置左右上下四个标识符，每一圈标识符改变
*/

class Solution {
public:
	vector<int> printMatrix(vector<vector<int> > matrix) {
		vector<int> res;
		int size_row = (int)matrix.size();
		int size_col = (int)matrix[0].size();
		int left = 0, right = size_col - 1, top = 0, btm = size_row - 1;
		while (left <= right && top <= btm) {
			for (int i = left; i <= right; i++) {
				res.push_back(matrix[top][i]);
			}
			if (top < btm) {
				for (int i = top + 1; i <= btm; i++) {
					res.push_back(matrix[i][right]);
				}
			}
			if (left < right && top < btm ) {
				for (int i = right - 1; i >= left; i--) {
					res.push_back(matrix[btm][i]);
				}
			}
			if (top < btm && left < right) {
				for (int i = btm - 1; i > top; i--) {
					res.push_back(matrix[i][left]);
				}
			}
			left++; right--; top++; btm--;
		}
		int size = res.size();
		for (int i = 0; i < size; i++) {
			cout << res[i] << " ";
		}
		cout << endl;
		return res;
	}
};

int main() {
	Solution s;
	vector<vector<int> > matirx(1);
	int num = 1;
	for (int i = 0; i < matirx.size(); ++i) {
		for (int j = 0; j < 5; ++j) {
			matirx[i].push_back(num);
			num++;
			cout << matirx[i][j] << " ";
		}
	}
	cout << endl;
	s.printMatrix(matirx);
	system("pause");
	return 0;
}
```