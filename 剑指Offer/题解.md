<!-- GFM-TOC -->
* [1. 二维数组中的查找](#1.二维数组中的查找)
* [2. 替换空格](#2.替换空格)
* [3. 从尾到头打印链表](#3.从尾到头打印链表)
* [4. 重建二叉树](#4.重建二叉树)
* [5. 用两个栈实现队列](#5.用两个栈实现队列)
* [6. 旋转数组的最小数字](#6.旋转数组的最小数字)
* [7. 斐波那契数列](#7.斐波那契数列)
* [8. 跳台阶](#8.跳台阶)
<!-- GFM-TOC -->

# 1.二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```C++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int row = (int)array.size();
        int col = (int)array[0].size();
        
        if(row == 0 || col == 0)
            return false;
        
        if(target < array[0][0] || target > array[row-1][col-1])
            return false;
        
        for(int i=0;i<row;i++){
            int l = 0,r = col - 1,m;
            while(l <= r){
                m = (l+r)/2;
                if(target == array[i][m])
                    return true;
                else if(target < array[i][m])
                    r = m - 1;
                else
                    l = m + 1;
            }
        }
        
        return false;
    }
};
```

# 2.替换空格

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```C++
class Solution {
public:
	void replaceSpace(char *str, int length) {
		int count = 0;
		for (int i = 0; i < length; i++) {
			if (str[i] == ' ')
				count++;
		}

		for (int i = length - 1; i >= 0; i--) {
			if (str[i] != ' ') {
				str[i + 2*count] = str[i];
			}
			else {
				count--;
				str[i + 2*count] = '%';
				str[i + 2 * count + 1] = '2';
				str[i + 2 * count + 2] = '0';
			}
		}
	}
};
```

# 3.从尾到头打印链表

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

```C++
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
	vector<int> printListFromTailToHead(ListNode* head) {
		vector<int> list;
		if (head != NULL) {
			list.insert(list.begin(), head->val);
			if (head->next != NULL) {
				vector<int> tempVal = printListFromTailToHead(head->next);
				if (tempVal.size() > 0)
					list.insert(list.begin(), tempVal.begin(), tempVal.end());
			}
		}
		return list;
	}
};
```

# 4.重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/**
* Definition for binary tree */
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	TreeNode * reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		int vin_len = vin.size();
		if (vin_len == 0)
			return NULL;

		vector<int> pre_left, pre_right, vin_left, vin_right;

		TreeNode *root = new TreeNode(pre[0]);

		int root_index = 0;
		for (int i = 0; i < vin_len; i++) {
			if (vin[i] == root->val) {
				root_index = i;
				break;
			}
		}
		//构建左子树
		for (int i = 0; i < root_index; i++) {
			vin_left.push_back(vin[i]);
			pre_left.push_back(pre[i + 1]);
		}
		//构建右子树
		for (int i = root_index + 1; i < vin_len; i++) {
			vin_right.push_back(vin[i]);
			pre_right.push_back(pre[i]);
		}
		root->left = reConstructBinaryTree(pre_left, vin_left);
		root->right = reConstructBinaryTree(pre_right, vin_right);
		return root;
	}

	vector<int> PrintFromTopToBottom(TreeNode* root) {
		TreeNode* fr;
		if (root == NULL) {
			return result;
		}
		que.push(root);
		while (!que.empty()) {
			fr = que.front();
			result.push_back(fr->val);
			if (fr->left != NULL) {
				que.push(fr->left);
			}
			if (fr->right != NULL) {
				que.push(fr->right);
			}
			que.pop();
		}
		return result;
	}
private:
	vector<int> result;
	queue<TreeNode*> que;

};

int main() {
	Solution s;
	int a[8] = { 1,2,4,7,3,5,6,8 };
	int b[8] = { 4,7,2,1,5,3,8,6 };
	vector<int> pre;
	pre.insert(pre.begin(), a, a + 8);
	vector<int> vin;
	vin.insert(vin.begin(), b, b + 8);
	TreeNode *root = s.reConstructBinaryTree(pre, vin);
	vector<int> result = s.PrintFromTopToBottom(root);
	vector<int>::iterator it;
	for (it = result.begin(); it != result.end(); ++it) {
		cout << *it << endl;
	}

	system("pause");
	return 0;
}

/*
*                   1
*                 *    *
*              2          3
*            *           *   *
*          4            5      6
*         *
*       8
*/
```

# 5.用两个栈实现队列

```C++
/* 题目：用两个栈实现队列
* 题目描述
* 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
*/

#include<iostream>
#include<stack>
using namespace std;

class Solution
{
public:
	void push(int node) {
		stack1.push(node);
	}

	int pop() {
		int res = 0;
		if (stack2.size() > 0) {
			res = stack2.top();
			stack2.pop();
		}
		else if (stack1.size() > 0) {
			while (stack1.size() > 0) {
				stack2.push(stack1.top());
				stack1.pop();
			}
			res = stack2.top();
			stack2.pop();
		}
		return res;
	}

private:
	stack<int> stack1;
	stack<int> stack2;
};

int main() {
	Solution s;
	s.push(5);
	s.push(6);
	s.pop();
	system("pause");
	return 0;
}
```

# 6.旋转数组的最小数字

```C++
/* 题目：旋转数组的最小数字
* 题目描述
* 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
* 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。
* 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
* NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
*/

#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
	int minNumberInRotateArray(vector<int> rotateArray) {
		int size = rotateArray.size();
		if (size == 0) {
			return 0;
		}
		int left = 0, right = size - 1;
		int mid = 0;
		while (rotateArray[left] >= rotateArray[right]) {
			if (right - left == 1) {
				mid = right;
				break;
			}
			mid = (left + right) / 2;
			if (rotateArray[left] == rotateArray[right] && rotateArray[left] == rotateArray[mid]) {
				return MinNumber(rotateArray, left, right);
			}
			if (rotateArray[mid] >= rotateArray[left]) {
				left = mid;
			}
			else {
				right = mid;
			}
		}
		return rotateArray[mid];
	}
private:
	int MinNumber(vector<int> &num, int left, int right) {
		int res = num[left];
		for (int i = left + 1; i < right; i++) {
			if (num[i] < res) {
				res = num[i];
			}
		}
		return res;
	}
};

int main() {
	Solution s;
	vector<int> num = { 4,5,6,7,1,2,3 };
	cout << s.minNumberInRotateArray(num) << endl;
	system("pause");
	return 0;
}
```

# 7.斐波那契数列

```C++
/* 题目：斐波那契数列
* 题目描述
* 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
*/

#include<iostream>
using namespace std;

class Solution {
public:
	/*int Fibonacci(int n) {
	if (n < 0)
	return -1;
	else if (n == 0)
	return 0;
	else if (n == 1)
	return 1;
	else
	return Fibonacci(n - 1) + Fibonacci(n - 2);
	}*/ //递归时间消耗太大
	int Fibonacci(int n) {
		if (n < 0)
			return -1;
		else if (n == 0)
			return 0;
		else if (n == 1 || n == 2)
			return 1;
		else {
			int first = 1, second = 1, temp;
			for (int i = 2; i < n; i++) {
				temp = first + second;
				first = second;
				second = temp;
			}
			return temp;
		}
	}
};

int main() {
	Solution s;
	cout << s.Fibonacci(5) << endl;
	system("pause");
	return 0;
}
```

# 8.跳台阶

```C++
/* 题目：跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
* 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 总跳法是f(n) = f(n-1) + f(n-2);
f(1) = 1; f(2) = 2; f(3) = 3;Fibonacci数列
*/

/* 
* 递归方法对时间和空间的消耗比较大。
*/

#include<iostream>
using namespace std;

class Solution {
public:
	int jumpFloor(int number) {
		/*if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			return jumpFloor(number - 1) + jumpFloor(number - 2);
		}*/
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if(number == 2){
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloor(5) << endl;
	system("pause");
	return 0;
}
```

# 9.变态跳台阶

```C++
#include<iostream>
using namespace std;

/* 题目：变态跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 第一次跳是n级，那么剩下的是0个台阶，跳法是f(0);
总跳法是f(n) = f(n-1) + f(n-2) + ... + f(1) + f(0);
f(n - 1) = f(n - 2) + ... + f(0);
f(n) = f(n-1)+ f(n-1) = 2*f(n-1);
f(0) = 1;
f(1) = 1;
f(2) = 2;
*/

class Solution {
public:
	int jumpFloorII(int number) {
		if (number == 0 || number == 1) {
			return 1;
		}
		else if (number > 0) {
			int res = 1;
			for (int i = 2; i <= number; i++) {
				res = 2 * res;
			}
			return res;
		}
		else {
			return 0;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloorII(5) << endl;
	system("pause");
	return 0;
}
```

# 9.矩形覆盖

```C++
#include<iostream>
using namespace std;

/* 题目：矩形覆盖
* 题目描述
* 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
* 请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
*/

/* 
1. 当n=1时，只有一种方法；
2. 当n=2时，有两种方法；
第一块横着放，f(n-2)种放法；
第一块竖着放，f(n-1)种放法。
f(n) = f(n-1) + f(n-2);
*/

class Solution {
public:
	int rectCover(int number) {
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}

	}
};

int main() {
	Solution s;
	cout << s.rectCover(4) << endl;
	system("pause");
	return 0;
}
```

# 9.变态跳台阶

```C++
```


# 9.变态跳台阶

```C++
```

# 9.变态跳台阶

```C++
```